import{r as x,aa as C,E as I}from"./index-2dd0b517.js";const w=t=>{let e;const n=new Set,o=(l,h)=>{const s=typeof l=="function"?l(e):l;if(!Object.is(s,e)){const d=e;e=h??typeof s!="object"?s:Object.assign({},e,s),n.forEach(p=>p(e,d))}},r=()=>e,i={setState:o,getState:r,subscribe:l=>(n.add(l),()=>n.delete(l)),destroy:()=>{({BASE_URL:"/react/",MODE:"production",DEV:!1,PROD:!0,SSR:!1}&&"production")!=="production"&&console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),n.clear()}};return e=t(o,r,i),i},P=t=>t?w(t):w;var _={},M={get exports(){return _},set exports(t){_=t}},b={};/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var g=x,k=C;function U(t,e){return t===e&&(t!==0||1/t===1/e)||t!==t&&e!==e}var V=typeof Object.is=="function"?Object.is:U,z=k.useSyncExternalStore,N=g.useRef,L=g.useEffect,J=g.useMemo,A=g.useDebugValue;b.useSyncExternalStoreWithSelector=function(t,e,n,o,r){var S=N(null);if(S.current===null){var E={hasValue:!1,value:null};S.current=E}else E=S.current;S=J(function(){function l(a){if(!h){if(h=!0,s=a,a=o(a),r!==void 0&&E.hasValue){var v=E.value;if(r(v,a))return d=v}return d=a}if(v=d,V(s,a))return v;var c=o(a);return r!==void 0&&r(v,c)?v:(s=a,d=c)}var h=!1,s,d,p=n===void 0?null:n;return[function(){return l(e())},p===null?void 0:function(){return l(p())}]},[e,n,o,r]);var i=z(t,S[0],S[1]);return L(function(){E.hasValue=!0,E.value=i},[i]),A(i),i};(function(t){t.exports=b})(M);const F=I(_),{useSyncExternalStoreWithSelector:W}=F;function X(t,e=t.getState,n){const o=W(t.subscribe,t.getState,t.getServerState||t.getState,e,n);return x.useDebugValue(o),o}const T=t=>{({BASE_URL:"/react/",MODE:"production",DEV:!1,PROD:!0,SSR:!1}&&"production")!=="production"&&typeof t!="function"&&console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.");const e=typeof t=="function"?P(t):t,n=(o,r)=>X(e,o,r);return Object.assign(n,e),n},G=t=>t?T(t):T,R=new Map,O=t=>{const e=R.get(t);return e?Object.fromEntries(Object.entries(e.stores).map(([n,o])=>[n,o.getState()])):{}},$=(t,e,n)=>{if(t===void 0)return{type:"untracked",connection:e.connect(n)};const o=R.get(n.name);if(o)return{type:"tracked",store:t,...o};const r={connection:e.connect(n),stores:{}};return R.set(n.name,r),{type:"tracked",store:t,...r}},j=(t,e={})=>(n,o,r)=>{const{enabled:S,anonymousActionType:E,store:i,...l}=e;let h;try{h=(S??({BASE_URL:"/react/",MODE:"production",DEV:!1,PROD:!0,SSR:!1}&&"production")!=="production")&&window.__REDUX_DEVTOOLS_EXTENSION__}catch{}if(!h)return({BASE_URL:"/react/",MODE:"production",DEV:!1,PROD:!0,SSR:!1}&&"production")!=="production"&&S&&console.warn("[zustand devtools middleware] Please install/enable Redux devtools extension"),t(n,o,r);const{connection:s,...d}=$(i,h,l);let p=!0;r.setState=(c,y,u)=>{const f=n(c,y);if(!p)return f;const m=u===void 0?{type:E||"anonymous"}:typeof u=="string"?{type:u}:u;return i===void 0?(s==null||s.send(m,o()),f):(s==null||s.send({...m,type:`${i}/${m.type}`},{...O(l.name),[i]:r.getState()}),f)};const a=(...c)=>{const y=p;p=!1,n(...c),p=y},v=t(r.setState,o,r);if(d.type==="untracked"?s==null||s.init(v):(d.stores[d.store]=r,s==null||s.init(Object.fromEntries(Object.entries(d.stores).map(([c,y])=>[c,c===d.store?v:y.getState()])))),r.dispatchFromDevtools&&typeof r.dispatch=="function"){let c=!1;const y=r.dispatch;r.dispatch=(...u)=>{({BASE_URL:"/react/",MODE:"production",DEV:!1,PROD:!0,SSR:!1}&&"production")!=="production"&&u[0].type==="__setState"&&!c&&(console.warn('[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'),c=!0),y(...u)}}return s.subscribe(c=>{var y;switch(c.type){case"ACTION":if(typeof c.payload!="string"){console.error("[zustand devtools middleware] Unsupported action format");return}return D(c.payload,u=>{if(u.type==="__setState"){if(i===void 0){a(u.state);return}Object.keys(u.state).length!==1&&console.error(`
                    [zustand devtools middleware] Unsupported __setState action format. 
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `);const f=u.state[i];if(f==null)return;JSON.stringify(r.getState())!==JSON.stringify(f)&&a(f);return}r.dispatchFromDevtools&&typeof r.dispatch=="function"&&r.dispatch(u)});case"DISPATCH":switch(c.payload.type){case"RESET":return a(v),i===void 0?s==null?void 0:s.init(r.getState()):s==null?void 0:s.init(O(l.name));case"COMMIT":if(i===void 0){s==null||s.init(r.getState());return}return s==null?void 0:s.init(O(l.name));case"ROLLBACK":return D(c.state,u=>{if(i===void 0){a(u),s==null||s.init(r.getState());return}a(u[i]),s==null||s.init(O(l.name))});case"JUMP_TO_STATE":case"JUMP_TO_ACTION":return D(c.state,u=>{if(i===void 0){a(u);return}JSON.stringify(r.getState())!==JSON.stringify(u[i])&&a(u[i])});case"IMPORT_STATE":{const{nextLiftedState:u}=c.payload,f=(y=u.computedStates.slice(-1)[0])==null?void 0:y.state;if(!f)return;a(i===void 0?f:f[i]),s==null||s.send(null,u);return}case"PAUSE_RECORDING":return p=!p}return}}),v},H=j,D=(t,e)=>{let n;try{n=JSON.parse(t)}catch(o){console.error("[zustand devtools middleware] Could not parse the received json",o)}n!==void 0&&e(n)};function K(t,e){if(Object.is(t,e))return!0;if(typeof t!="object"||t===null||typeof e!="object"||e===null)return!1;if(t instanceof Map&&e instanceof Map){if(t.size!==e.size)return!1;for(const[o,r]of t)if(!Object.is(r,e.get(o)))return!1;return!0}if(t instanceof Set&&e instanceof Set){if(t.size!==e.size)return!1;for(const o of t)if(!e.has(o))return!1;return!0}const n=Object.keys(t);if(n.length!==Object.keys(e).length)return!1;for(let o=0;o<n.length;o++)if(!Object.prototype.hasOwnProperty.call(e,n[o])||!Object.is(t[n[o]],e[n[o]]))return!1;return!0}export{G as c,H as d,K as s};
